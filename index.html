<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ph·∫ßn M·ªÅm H·ªó Tr·ª£ D·ª± ƒêo√°n X√°c Su·∫•t</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://unpkg.com/recharts@2.1.16/umd/Recharts.min.js"></script>
    <script src="https://unpkg.com/lucide-react@0.263.1/dist/lucide-react.js"></script>
    <style>
        body { font-family: sans-serif; }
    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useMemo, useRef } = React;
        const { BarChart, Bar, XAxis, YAxis, CartesianGrid, Tooltip, ResponsiveContainer, Legend } = Recharts;
        
        // --- COMPONENT CON ---
        const Icon = ({ name, ...props }) => {
            const LucideIcon = lucide[name];
            return LucideIcon ? <LucideIcon {...props} /> : null;
        };

        const CoinDisplay = ({ coin }) => (
          <div className="bg-white rounded-lg shadow-lg p-6 flex flex-col items-center justify-center h-full">
            <h3 className="text-lg font-semibold text-gray-800 mb-4">
              ƒê·ªìng xu {coin.id}
            </h3>
            <div className="relative w-24 h-24 mx-auto mb-4">
              <div className={`w-24 h-24 rounded-full flex items-center justify-center text-white font-bold text-lg transition-all duration-300 ${
                coin.isFlipping ? 'animate-spin' : ''
              } ${
                coin.result === 'ƒê·ªè' ? 'bg-red-500' :
                coin.result === 'Tr·∫Øng' ? 'bg-gray-300 text-gray-700' :
                'bg-gray-200 border-4 border-dashed border-gray-400'
              }`}>
                {coin.isFlipping ? '?' : (coin.result || '?')}
              </div>
            </div>
            <div className="text-sm text-gray-600">
              {coin.result ? coin.result : 'Ch·ªù k·∫øt qu·∫£'}
            </div>
          </div>
        );

        const CompactHistoryItem = ({ result }) => (
            <div className="flex items-center justify-between p-2 bg-gray-50 rounded-lg text-sm">
                <div className="flex items-center gap-3">
                    <span className="font-medium text-gray-600">#{result.flip}</span>
                    <div className="flex gap-1">
                        {result.outcome.split(', ').map((coin, i) => (
                            <div key={i} className={`w-5 h-5 rounded-full ${coin === 'ƒê·ªè' ? 'bg-red-500' : 'bg-gray-300'}`} />
                        ))}
                    </div>
                    <span className="font-bold text-blue-600">{result.redCount} ƒê·ªè</span>
                </div>
                <div className="flex items-center gap-3 text-xs text-gray-500">
                    {result.predictionAtFlip && (
                        <div className={`flex items-center gap-1 px-2 py-0.5 rounded-full ${result.redCount === result.predictionAtFlip.value ? 'bg-green-100 text-green-700' : 'bg-red-100 text-red-700'}`}>
                            {result.redCount === result.predictionAtFlip.value ? <Icon name="CheckCircle" size={12}/> : <Icon name="XCircle" size={12}/>}
                            <span>D·ª± ƒëo√°n: {result.predictionAtFlip.value}</span>
                        </div>
                    )}
                    {result.isFromVision && <Icon name="ScanEye" size={12} className="text-purple-500" title="K·∫øt qu·∫£ t·ª´ Vision AI"/>}
                    <span>{result.timestamp}</span>
                </div>
            </div>
        );

        const VisualHistoryItem = ({ result }) => (
            <div className="flex items-center justify-between p-3 bg-gray-100 rounded-lg mb-2 shadow-sm">
                <div className="flex items-center gap-4">
                    <span className="font-bold text-gray-700 text-base w-10 text-center">#{result.flip}</span>
                    <div className="flex gap-2">
                        {result.outcome.split(', ').map((coin, i) => (
                            <div key={i} className={`w-10 h-10 rounded-full flex items-center justify-center text-xs font-bold shadow-inner ${coin === 'ƒê·ªè' ? 'bg-red-500 text-white' : 'bg-gray-300 text-gray-700'}`}>
                                {coin === 'ƒê·ªè' ? 'ƒê·ªé' : 'TR·∫ÆNG'}
                            </div>
                        ))}
                    </div>
                </div>
                <div className="flex flex-col items-end gap-1 text-xs text-gray-500">
                    <div className="font-bold text-lg text-blue-600">{result.redCount} ƒê·ªè</div>
                    {result.predictionAtFlip && (
                        <div className={`flex items-center gap-1 px-2 py-0.5 rounded-full ${result.redCount === result.predictionAtFlip.value ? 'bg-green-100 text-green-700' : 'bg-red-100 text-red-700'}`}>
                            {result.redCount === result.predictionAtFlip.value ? <Icon name="CheckCircle" size={12}/> : <Icon name="XCircle" size={12}/>}
                            <span>D·ª± ƒëo√°n: {result.predictionAtFlip.value}</span>
                        </div>
                    )}
                    {result.isFromVision && <Icon name="ScanEye" size={12} className="text-purple-500" title="K·∫øt qu·∫£ t·ª´ Vision AI"/>}
                    <span>{result.timestamp}</span>
                </div>
            </div>
        );

        const VisionAnalyzer = ({ onNewResult }) => {
            const videoRef = useRef(null);
            const canvasRef = useRef(null);
            const [isCapturing, setIsCapturing] = useState(false);
            const [stream, setStream] = useState(null);
            const [analysisRegions, setAnalysisRegions] = useState([
                { x: 25, y: 25, color: null }, { x: 75, y: 25, color: null },
                { x: 25, y: 75, color: null }, { x: 75, y: 75, color: null },
            ]);
            const [lastResult, setLastResult] = useState(null);

            const startCapture = async () => {
                try {
                    const mediaStream = await navigator.mediaDevices.getDisplayMedia({
                        video: { cursor: "never" },
                        audio: false
                    });
                    setStream(mediaStream);
                    if (videoRef.current) {
                        videoRef.current.srcObject = mediaStream;
                    }
                    setIsCapturing(true);
                } catch (err) {
                    console.error("Error starting screen capture:", err);
                    alert("Kh√¥ng th·ªÉ b·∫Øt ƒë·∫ßu ghi h√¨nh. Vui l√≤ng c·∫•p quy·ªÅn chia s·∫ª m√†n h√¨nh.");
                }
            };

            const stopCapture = () => {
                if (stream) {
                    stream.getTracks().forEach(track => track.stop());
                }
                setStream(null);
                setIsCapturing(false);
                setLastResult(null);
            };

            useEffect(() => {
                let intervalId;
                if (isCapturing && videoRef.current) {
                    const video = videoRef.current;
                    const canvas = canvasRef.current;
                    const ctx = canvas.getContext('2d', { willReadFrequently: true });

                    intervalId = setInterval(() => {
                        if (video.readyState < 2) return;
                        canvas.width = video.videoWidth;
                        canvas.height = video.videoHeight;
                        ctx.drawImage(video, 0, 0, canvas.width, canvas.height);

                        let currentRedCount = 0;
                        const newRegions = analysisRegions.map(region => {
                            const pixelX = Math.floor((region.x / 100) * canvas.width);
                            const pixelY = Math.floor((region.y / 100) * canvas.height);
                            const pixelData = ctx.getImageData(pixelX, pixelY, 1, 1).data;
                            const [r, g, b] = pixelData;
                            
                            let detectedColor = 'Tr·∫Øng';
                            if (r > 150 && g < 100 && b < 100) {
                                detectedColor = 'ƒê·ªè';
                                currentRedCount++;
                            }
                            return { ...region, color: `rgb(${r},${g},${b})` };
                        });
                        
                        setAnalysisRegions(newRegions);

                        if (lastResult === null || currentRedCount !== lastResult) {
                            setLastResult(currentRedCount);
                            if (lastResult !== null) {
                                onNewResult(currentRedCount);
                            }
                        }
                    }, 500);
                }
                return () => clearInterval(intervalId);
            }, [isCapturing, analysisRegions, lastResult, onNewResult]);

            return (
                <div className="bg-white rounded-lg shadow-lg p-6 border-t-4 border-teal-500">
                    <div className="flex items-center justify-between mb-4">
                        <h2 className="text-lg font-semibold text-teal-800">üî¨ Ph√¢n t√≠ch Vision AI</h2>
                        <button onClick={isCapturing ? stopCapture : startCapture} className={`flex items-center gap-2 px-3 py-2 rounded-lg text-sm font-medium text-white ${isCapturing ? 'bg-red-500 hover:bg-red-600' : 'bg-teal-500 hover:bg-teal-600'}`}>
                            {isCapturing ? <Icon name="VideoOff" size={16} /> : <Icon name="Video" size={16} />}
                            {isCapturing ? 'D·ª´ng Ghi' : 'B·∫Øt ƒë·∫ßu Ghi h√¨nh'}
                        </button>
                    </div>
                    <div className="relative bg-gray-200 rounded-lg overflow-hidden aspect-video">
                        <video ref={videoRef} autoPlay muted className="w-full h-full object-contain" />
                        <canvas ref={canvasRef} className="hidden" />
                        {isCapturing && (
                            <div className="absolute inset-0">
                                {analysisRegions.map((region, i) => (
                                    <div key={i} className="absolute w-4 h-4 -translate-x-1/2 -translate-y-1/2 border-2 rounded-full flex items-center justify-center" style={{ left: `${region.x}%`, top: `${region.y}%`, borderColor: region.color || 'magenta' }}>
                                       <div className="w-1 h-1 bg-white rounded-full"></div>
                                    </div>
                                ))}
                            </div>
                        )}
                        {!isCapturing && (
                            <div className="absolute inset-0 flex flex-col items-center justify-center text-gray-500 p-4 text-center">
                                <Icon name="ScanEye" size={48} className="mb-2 opacity-50"/>
                                <p className="font-medium">Ch∆∞a ghi h√¨nh</p>
                                <p className="text-xs">Nh·∫•n "B·∫Øt ƒë·∫ßu Ghi h√¨nh" v√† ch·ªçn c·ª≠a s·ªï ·ª©ng d·ª•ng b·∫°n mu·ªën ph√¢n t√≠ch.</p>
                            </div>
                        )}
                    </div>
                     <div className="mt-4 text-xs text-gray-600 bg-teal-50 p-3 rounded-lg">
                        <strong>H∆∞·ªõng d·∫´n:</strong> C√°c ch·∫•m m√†u tr√™n video l√† 4 ƒëi·ªÉm m√† AI ƒëang "nh√¨n" ƒë·ªÉ nh·∫≠n di·ªán m√†u s·∫Øc. H√£y ƒë·∫£m b·∫£o 4 ƒë·ªìng xu trong ·ª©ng d·ª•ng kia n·∫±m ƒë√∫ng v√†o 4 v·ªã tr√≠ n√†y.
                    </div>
                </div>
            );
        };

        const App = () => {
          const [coins, setCoins] = useState([
            { id: 1, result: null, isFlipping: false }, { id: 2, result: null, isFlipping: false },
            { id: 3, result: null, isFlipping: false }, { id: 4, result: null, isFlipping: false }
          ]);
          const [isFlipping, setIsFlipping] = useState(false);
          
          const [results, setResults] = useState(() => {
            try {
              const savedResults = localStorage.getItem('coinFlipHistory');
              return savedResults ? JSON.parse(savedResults) : [];
            } catch (error) { return []; }
          });

          const [autoMode, setAutoMode] = useState(false);
          const [showHistoryInput, setShowHistoryInput] = useState(false);
          const [historyInput, setHistoryInput] = useState('');
          const [prediction, setPrediction] = useState(null);
          const [patterns, setPatterns] = useState({});
          const [isAnalyzing, setIsAnalyzing] = useState(false);
          const [visualHistory, setVisualHistory] = useState(false);

          const theoreticalProbabilities = useMemo(() => {
            const factorial = (n) => (n <= 1 ? 1 : n * factorial(n - 1));
            const probabilities = [];
            for (let redCount = 0; redCount <= 4; redCount++) {
              const combinations = factorial(4) / (factorial(redCount) * factorial(4 - redCount));
              probabilities.push({
                outcome: `${redCount} ƒê·ªè`,
                probability: (combinations / 16) * 100,
              });
            }
            return probabilities;
          }, []);

          const statistics = useMemo(() => {
            if (results.length === 0) return {};
            const redCounts = results.map(r => r.redCount);
            const stats = {};
            for (let i = 0; i <= 4; i++) {
              const count = redCounts.filter(rc => rc === i).length;
              stats[i] = {
                observedPercent: (count / results.length * 100),
              };
            }
            return stats;
          }, [results]);
          
          const accuracyStats = useMemo(() => {
            const relevantResults = results.filter(r => r.predictionAtFlip);
            if (relevantResults.length === 0) return { correct: 0, total: 0, accuracy: 0 };
            const correct = relevantResults.filter(r => r.redCount === r.predictionAtFlip.value).length;
            const total = relevantResults.length;
            return { correct, total, accuracy: total > 0 ? (correct / total * 100) : 0 };
          }, [results]);

          const analyzeAndPredict = (currentResults) => {
            if (currentResults.length < 5) {
              setPrediction(null);
              return;
            }
            setIsAnalyzing(true);
            setTimeout(() => {
              const redCounts = currentResults.map(r => r.redCount);
              const predictByFrequency = (data) => parseInt(Object.keys(data.reduce((acc, val) => ({ ...acc, [val]: (acc[val] || 0) + 1 }), {})).reduce((a, b) => data[a] > data[b] ? a : b));
              const predictByMarkov = (data) => {
                if (data.length < 2) return null;
                const transitions = {};
                for (let i = 0; i < data.length - 1; i++) {
                    if (!transitions[data[i]]) transitions[data[i]] = {};
                    transitions[data[i]][data[i+1]] = (transitions[data[i]][data[i+1]] || 0) + 1;
                }
                const last = data[data.length - 1];
                if (transitions[last]) return parseInt(Object.keys(transitions[last]).reduce((a, b) => transitions[last][a] > transitions[last][b] ? a : b));
                return null;
              };
              const predictions = {
                'T·∫ßn su·∫•t cao nh·∫•t': predictByFrequency(redCounts),
                'Chu·ªói Markov': predictByMarkov(redCounts.slice(-20)),
                'ƒê·∫£o ng∆∞·ª£c xu th·∫ø': 4 - redCounts[redCounts.length - 1]
              };
              const validPredictions = Object.values(predictions).filter(p => p !== null);
              const counts = validPredictions.reduce((acc, p) => ({ ...acc, [p]: (acc[p] || 0) + 1 }), {});
              const mostCommon = Object.keys(counts).reduce((a, b) => counts[a] > counts[b] ? a : b, null);
              if (mostCommon !== null) {
                setPrediction({
                  value: parseInt(mostCommon),
                  confidence: Math.round((counts[mostCommon] / validPredictions.length) * 100),
                });
              }
              setPatterns({
                average: (redCounts.reduce((a, b) => a + b, 0) / redCounts.length).toFixed(2),
                recent: redCounts.slice(-5),
              });
              setIsAnalyzing(false);
            }, 500);
          };

          const addNewResult = (redCount, isFromVision = false) => {
            const outcome = Array(4).fill('Tr·∫Øng').map((_, i) => i < redCount ? 'ƒê·ªè' : 'Tr·∫Øng');
            setResults(prev => {
                const newResult = {
                    flip: (prev[prev.length - 1]?.flip || 0) + 1,
                    outcome: outcome.join(', '),
                    redCount: redCount,
                    timestamp: new Date().toLocaleTimeString(),
                    isImported: !isFromVision,
                    isFromVision: isFromVision,
                    predictionAtFlip: prediction
                };
                return [...prev, newResult].slice(-100);
            });
          };

          const flipCoins = () => {
            if (isFlipping) return;
            setIsFlipping(true);
            setCoins(coins.map(c => ({ ...c, isFlipping: true, result: null })));
            setTimeout(() => {
              let redCount = 0;
              const newCoinStates = coins.map(c => {
                  const result = Math.random() < 0.5 ? 'ƒê·ªè' : 'Tr·∫Øng';
                  if (result === 'ƒê·ªè') redCount++;
                  return { ...c, result, isFlipping: false };
              });
              setCoins(newCoinStates);
              setIsFlipping(false);
              addNewResult(redCount, false);
            }, 1500);
          };
          
          const processHistoryInput = () => {
            try {
              const lines = historyInput.trim().split('\n').filter(Boolean);
              const newResults = lines.map((line, index) => {
                let redCount = /^\d+$/.test(line.trim()) ? parseInt(line.trim()) : (line.trim().toUpperCase().match(/[ƒêDR1]/g) || []).length;
                if (redCount < 0 || redCount > 4) throw new Error(`Invalid red count on line ${index + 1}`);
                const outcome = Array(4).fill('Tr·∫Øng').map((_, i) => i < redCount ? 'ƒê·ªè' : 'Tr·∫Øng');
                return {
                  flip: (results[results.length - 1]?.flip || 0) + index + 1,
                  outcome: outcome.join(', '), redCount,
                  timestamp: new Date().toLocaleTimeString(), isImported: true, predictionAtFlip: null
                };
              });
              if (newResults.length > 0) {
                setResults(prev => [...prev, ...newResults].slice(-100));
                setHistoryInput(''); setShowHistoryInput(false);
              }
            } catch (error) { alert(`L·ªói ƒë·ªãnh d·∫°ng d·ªØ li·ªáu: ${error.message}.`); }
          };

          const resetResults = () => {
            if (window.confirm("B·∫°n c√≥ ch·∫Øc ch·∫Øn mu·ªën x√≥a to√†n b·ªô l·ªãch s·ª≠ kh√¥ng?")) {
                setResults([]); setPrediction(null); setPatterns({});
                setCoins(coins.map(c => ({ ...c, result: null })));
                localStorage.removeItem('coinFlipHistory');
            }
          };

          useEffect(() => {
            localStorage.setItem('coinFlipHistory', JSON.stringify(results));
            analyzeAndPredict(results);
          }, [results]);

          useEffect(() => {
            let timer;
            if (autoMode && !isFlipping) timer = setTimeout(flipCoins, 2000);
            return () => clearTimeout(timer);
          }, [autoMode, isFlipping, coins]);

          const flipCount = results.length;
          const barChartData = theoreticalProbabilities.map((prob, index) => ({
            name: prob.outcome,
            "L√Ω thuy·∫øt": prob.probability,
            "Th·ª±c t·∫ø": statistics[index]?.observedPercent || 0
          }));

          return (
            <div className="min-h-screen bg-gray-50 p-4">
              <div className="max-w-7xl mx-auto">
                <header className="bg-white rounded-lg shadow-lg p-4 mb-6">
                  <div className="flex flex-wrap items-center justify-between gap-4">
                    <div className="flex items-center space-x-3">
                      <Icon name="Coins" className="w-10 h-10 text-red-600" />
                      <div>
                        <h1 className="text-2xl font-bold text-gray-800">Ph·∫ßn M·ªÅm H·ªó Tr·ª£ D·ª± ƒêo√°n X√°c Su·∫•t</h1>
                        <p className="text-sm text-gray-600">M√¥ ph·ªèng, Ph√¢n t√≠ch & D·ª± ƒëo√°n k·∫øt qu·∫£ 4 ƒë·ªìng xu</p>
                      </div>
                    </div>
                    <div className="flex items-center flex-wrap gap-2">
                      <span className="text-sm font-medium text-gray-700 px-3 py-2 bg-gray-100 rounded-lg">L·∫ßn tung: <span className="font-bold text-blue-600">{flipCount}</span></span>
                      <button onClick={() => setShowHistoryInput(p => !p)} className="flex items-center gap-2 px-3 py-2 bg-purple-500 hover:bg-purple-600 text-white rounded-lg text-sm"><Icon name="Upload" size={16} /> Nh·∫≠p L·ªãch s·ª≠</button>
                      <button onClick={resetResults} className="flex items-center gap-2 px-3 py-2 bg-gray-500 hover:bg-gray-600 text-white rounded-lg text-sm"><Icon name="RotateCcw" size={16} /> Reset</button>
                      <button onClick={() => setAutoMode(p => !p)} className={`flex items-center gap-2 px-3 py-2 rounded-lg text-sm font-medium text-white ${autoMode ? 'bg-orange-500 hover:bg-orange-600' : 'bg-green-500 hover:bg-green-600'}`}>{autoMode ? <Icon name="Pause" size={16} /> : <Icon name="Play" size={16} />} {autoMode ? 'D·ª´ng' : 'T·ª± ƒë·ªông'}</button>
                      <button onClick={flipCoins} disabled={isFlipping} className="flex items-center gap-2 px-4 py-2 bg-blue-500 hover:bg-blue-600 disabled:bg-gray-400 text-white rounded-lg font-medium text-sm"><Icon name="Coins" size={16} /> {isFlipping ? 'ƒêang tung...' : 'Tung Xu'}</button>
                    </div>
                  </div>
                </header>

                {showHistoryInput && (
                  <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 p-4">
                    <div className="bg-white rounded-lg shadow-xl p-6 w-full max-w-2xl">
                      <div className="flex items-center justify-between mb-4">
                        <h2 className="text-lg font-semibold text-gray-800">Nh·∫≠p L·ªãch s·ª≠ K·∫øt qu·∫£</h2>
                        <button onClick={() => setShowHistoryInput(false)} className="text-gray-500 hover:text-gray-700">‚úï</button>
                      </div>
                      <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
                        <div>
                          <label className="block text-sm font-medium text-gray-700 mb-2">Nh·∫≠p k·∫øt qu·∫£ (m·ªói d√≤ng m·ªôt l·∫ßn tung):</label>
                          <textarea value={historyInput} onChange={(e) => setHistoryInput(e.target.value)} placeholder="V√≠ d·ª•:&#10;2&#10;1&#10;ƒêTƒêT&#10;3&#10;RTTR" className="w-full h-40 px-3 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 font-mono text-sm"/>
                          <button onClick={processHistoryInput} className="mt-2 w-full px-4 py-2 bg-blue-500 hover:bg-blue-600 text-white rounded-lg">X·ª≠ l√Ω d·ªØ li·ªáu</button>
                        </div>
                        <div className="space-y-2 text-sm text-gray-600 bg-gray-50 p-4 rounded-lg">
                            <h3 className="font-medium text-gray-700 mb-2">H∆∞·ªõng d·∫´n:</h3>
                            <p><strong>ƒê·ªãnh d·∫°ng s·ªë:</strong> Nh·∫≠p s·ªë ƒë·ªìng ƒë·ªè (0-4).</p>
                            <p><strong>ƒê·ªãnh d·∫°ng k√Ω t·ª±:</strong> ƒê/D/R/1 = ƒê·ªè, T/W/0 = Tr·∫Øng.</p>
                            <p className="mt-2 text-xs text-yellow-700 bg-yellow-100 p-2 rounded">M·ªói d√≤ng l√† m·ªôt l·∫ßn tung, t·ªëi ƒëa 4 ƒë·ªìng.</p>
                        </div>
                      </div>
                    </div>
                  </div>
                )}

                <div className="grid grid-cols-1 lg:grid-cols-3 gap-6">
                  <div className="lg:col-span-1 space-y-6">
                    <VisionAnalyzer onNewResult={(redCount) => addNewResult(redCount, true)} />
                    <div className="bg-white rounded-lg shadow-lg p-6 border-t-4 border-purple-500">
                        <div className="flex items-center justify-between mb-4">
                            <h2 className="text-lg font-semibold text-purple-800">üîÆ D·ª± ƒêo√°n AI</h2>
                            <Icon name="Brain" className="w-6 h-6 text-purple-600" />
                        </div>
                        {isAnalyzing ? <div className="text-center py-8 text-gray-500">ƒêang ph√¢n t√≠ch...</div> : prediction ? (
                            <div>
                                <div className="text-center mb-4">
                                    <div className="text-4xl font-bold text-purple-600 mb-2">{prediction.value} ƒê·ªè</div>
                                    <div className="flex items-center justify-center space-x-2">
                                        <Icon name="Target" className="w-4 h-4 text-green-600" />
                                        <span className="text-sm font-medium text-green-600">ƒê·ªô tin c·∫≠y: {prediction.confidence}%</span>
                                    </div>
                                </div>
                            </div>
                        ) : <div className="text-center py-8 text-gray-500">Ch∆∞a ƒë·ªß d·ªØ li·ªáu.</div>}
                    </div>
                  </div>

                  <div className="lg:col-span-2 space-y-6">
                    <div className="grid grid-cols-1 md:grid-cols-3 gap-4">
                        <div className="bg-white p-4 rounded-lg shadow-lg text-center"><h3 className="text-sm font-medium text-gray-500">ƒê·ªô ch√≠nh x√°c AI</h3><p className={`text-2xl font-bold ${accuracyStats.accuracy > 60 ? 'text-green-600' : accuracyStats.accuracy > 40 ? 'text-yellow-500' : 'text-red-500'}`}>{accuracyStats.accuracy.toFixed(1)}%</p><p className="text-xs text-gray-500">{accuracyStats.correct}/{accuracyStats.total} ƒë√∫ng</p></div>
                        <div className="bg-white p-4 rounded-lg shadow-lg text-center"><h3 className="text-sm font-medium text-gray-500">Trung b√¨nh</h3><p className="text-2xl font-bold text-blue-600">{patterns.average || 'N/A'}</p><p className="text-xs text-gray-500">s·ªë m·∫∑t ƒë·ªè / l·∫ßn tung</p></div>
                        <div className="bg-white p-4 rounded-lg shadow-lg text-center"><h3 className="text-sm font-medium text-gray-500">5 l·∫ßn g·∫ßn nh·∫•t</h3><p className="text-2xl font-bold text-gray-700">{patterns.recent?.join(', ') || 'N/A'}</p><p className="text-xs text-gray-500">K·∫øt qu·∫£</p></div>
                    </div>

                    <div className="bg-white rounded-lg shadow-lg p-6">
                      <h2 className="text-lg font-semibold text-gray-800 mb-4">Ph√¢n B·ªë K·∫øt Qu·∫£</h2>
                      {results.length > 0 ? (
                        <ResponsiveContainer width="100%" height={250}>
                          <BarChart data={barChartData} margin={{ top: 5, right: 20, left: -10, bottom: 5 }}>
                            <CartesianGrid strokeDasharray="3 3" /><XAxis dataKey="name" /><YAxis unit="%" /><Tooltip formatter={(value) => `${value.toFixed(1)}%`} /><Legend /><Bar dataKey="L√Ω thuy·∫øt" fill="#8884d8" /><Bar dataKey="Th·ª±c t·∫ø" fill="#82ca9d" />
                          </BarChart>
                        </ResponsiveContainer>
                      ) : <div className="text-center text-gray-500 py-16">Ch∆∞a c√≥ d·ªØ li·ªáu.</div>}
                    </div>

                    <div className="bg-white rounded-lg shadow-lg p-6">
                      <div className="flex items-center justify-between mb-4">
                        <h2 className="text-lg font-semibold text-gray-800">L·ªãch S·ª≠ K·∫øt Qu·∫£</h2>
                        <button onClick={() => setVisualHistory(p => !p)} className="p-2 rounded-md hover:bg-gray-100 text-gray-600" title={visualHistory ? "Xem thu g·ªçn" : "Xem tr·ª±c quan"}>{visualHistory ? <Icon name="List" size={20} /> : <Icon name="Grid" size={20} />}</button>
                      </div>
                      <div className="max-h-96 overflow-y-auto pr-2">
                        {results.length > 0 ? (
                          <div className="space-y-2">{results.slice(-15).reverse().map((result) => visualHistory ? <VisualHistoryItem key={result.flip} result={result} /> : <CompactHistoryItem key={result.flip} result={result} />)}</div>
                        ) : <div className="text-center text-gray-500 py-8">Ch∆∞a c√≥ l·ªãch s·ª≠.</div>}
                      </div>
                    </div>
                  </div>
                </div>
              </div>
            </div>
          );
        };

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);

    </script>
</body>
</html>
