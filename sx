{/* C√¥ng th·ª©c v√† gi·∫£i th√≠ch */}
        <div className="bg-white rounded-lg shadow-lg p-6 mt-6">
          <h2 className="text-lg font-semibold text-gray-800 mb-4">üßÆ C√¥ng th·ª©c & Ph∆∞∆°ng ph√°p D·ª± ƒëo√°n</h2>
          
          <div className="grid grid-cols-1 lg:grid-cols-2 gapimport React, { useState, useEffect } from 'react';
import { BarChart, Bar, XAxis, YAxis, CartesianGrid, Tooltip, ResponsiveContainer, PieChart, Pie, Cell, LineChart, Line } from 'recharts';
import { Coins, Play, Pause, RotateCcw, TrendingUp, Calculator, Upload, Brain, Target } from 'lucide-react';

const CoinProbabilityPredictor = () => {
  const [coins, setCoins] = useState([
    { id: 1, result: null, isFlipping: false },
    { id: 2, result: null, isFlipping: false },
    { id: 3, result: null, isFlipping: false },
    { id: 4, result: null, isFlipping: false }
  ]);
  const [isFlipping, setIsFlipping] = useState(false);
  const [results, setResults] = useState([]);
  const [statistics, setStatistics] = useState({});
  const [autoMode, setAutoMode] = useState(false);
  const [flipCount, setFlipCount] = useState(0);
  const [showHistoryInput, setShowHistoryInput] = useState(false);
  const [historyInput, setHistoryInput] = useState('');
  const [prediction, setPrediction] = useState(null);
  const [patterns, setPatterns] = useState({});
  const [aiAnalysis, setAiAnalysis] = useState('');

  // T√≠nh to√°n t·∫•t c·∫£ c√°c k·∫øt qu·∫£ c√≥ th·ªÉ x·∫£y ra (2^4 = 16 k·∫øt qu·∫£)
  const getAllPossibleOutcomes = () => {
    const outcomes = [];
    for (let i = 0; i < 16; i++) {
      const binary = i.toString(2).padStart(4, '0');
      const outcome = binary.split('').map(bit => bit === '1' ? 'ƒê·ªè' : 'Tr·∫Øng');
      outcomes.push(outcome);
    }
    return outcomes;
  const factorial = (n) => {
    if (n <= 1) return 1;
    return n * factorial(n - 1);
  };

  // T√≠nh x√°c su·∫•t cho t·ª´ng k·∫øt qu·∫£
  const calculateProbabilities = () => {
    const probabilities = [];
    
    // X√°c su·∫•t cho s·ªë l∆∞·ª£ng ƒë·ªìng ƒë·ªè kh√°c nhau
    for (let redCount = 0; redCount <= 4; redCount++) {
      const combinations = factorial(4) / (factorial(redCount) * factorial(4 - redCount));
      const probability = (combinations / 16) * 100;
      probabilities.push({
        outcome: `${redCount} ƒê·ªè, ${4 - redCount} Tr·∫Øng`,
        probability: probability,
        count: combinations,
        redCount: redCount
      });
    }
    
    return probabilities;
  };

  // Ph√¢n t√≠ch pattern v√† ƒë∆∞a ra d·ª± ƒëo√°n
  const analyzePatterns = (resultsArray) => {
    if (resultsArray.length < 3) {
      setPrediction(null);
      setAiAnalysis('C·∫ßn √≠t nh·∫•t 3 l·∫ßn tung ƒë·ªÉ ph√¢n t√≠ch pattern');
      return;
    }

    const redCounts = resultsArray.map(r => r.redCount);
    const last5 = redCounts.slice(-5);
    const last10 = redCounts.slice(-10);
    
    // Ph√¢n t√≠ch xu h∆∞·ªõng
    const trend = calculateTrend(last10);
    const cyclePattern = findCyclePattern(redCounts);
    const frequency = calculateFrequency(redCounts);
    
    // D·ª± ƒëo√°n d·ª±a tr√™n multiple factors
    const predictions = {
      trend: predictByTrend(trend, redCounts),
      cycle: predictByCycle(cyclePattern, redCounts),
      frequency: predictByFrequency(frequency),
      markov: predictByMarkov(redCounts),
      regression: predictByRegression(redCounts)
    };
    
    // T·ªïng h·ª£p d·ª± ƒëo√°n
    const finalPrediction = combinePredictions(predictions);
    
    setPrediction(finalPrediction);
    setPatterns({
      trend,
      cycle: cyclePattern,
      frequency,
      recent: last5,
      average: (redCounts.reduce((a, b) => a + b, 0) / redCounts.length).toFixed(2)
    });
    
    // T·∫°o ph√¢n t√≠ch AI
    generateAIAnalysis(predictions, patterns, redCounts);
  };

  // T√≠nh xu h∆∞·ªõng tƒÉng/gi·∫£m
  const calculateTrend = (data) => {
    if (data.length < 2) return 0;
    let increases = 0, decreases = 0;
    for (let i = 1; i < data.length; i++) {
      if (data[i] > data[i-1]) increases++;
      else if (data[i] < data[i-1]) decreases++;
    }
    return (increases - decreases) / (data.length - 1);
  };

  // T√¨m pattern l·∫∑p l·∫°i
  const findCyclePattern = (data) => {
    const patterns = {};
    for (let len = 2; len <= Math.min(5, Math.floor(data.length/2)); len++) {
      for (let i = 0; i <= data.length - len * 2; i++) {
        const pattern = data.slice(i, i + len).join(',');
        const nextPattern = data.slice(i + len, i + len * 2).join(',');
        if (pattern === nextPattern) {
          patterns[pattern] = (patterns[pattern] || 0) + 1;
        }
      }
    }
    return Object.keys(patterns).length > 0 ? patterns : null;
  };

  // T√≠nh t·∫ßn su·∫•t xu·∫•t hi·ªán
  const calculateFrequency = (data) => {
    const freq = {};
    data.forEach(val => {
      freq[val] = (freq[val] || 0) + 1;
    });
    return freq;
  };

  // D·ª± ƒëo√°n theo xu h∆∞·ªõng
  const predictByTrend = (trend, data) => {
    const lastValue = data[data.length - 1];
    if (trend > 0.3) return Math.min(4, lastValue + 1);
    if (trend < -0.3) return Math.max(0, lastValue - 1);
    return lastValue;
  };

  // D·ª± ƒëo√°n theo cycle
  const predictByCycle = (cycles, data) => {
    if (!cycles) return null;
    const mostCommon = Object.keys(cycles).reduce((a, b) => cycles[a] > cycles[b] ? a : b);
    const pattern = mostCommon.split(',').map(Number);
    const recentMatch = data.slice(-pattern.length).join(',');
    if (recentMatch === mostCommon && data.length > pattern.length) {
      return pattern[0]; // D·ª± ƒëo√°n gi√° tr·ªã ti·∫øp theo trong cycle
    }
    return null;
  };

  // D·ª± ƒëo√°n theo t·∫ßn su·∫•t
  const predictByFrequency = (frequency) => {
    return parseInt(Object.keys(frequency).reduce((a, b) => frequency[a] > frequency[b] ? a : b));
  };

  // D·ª± ƒëo√°n theo Markov Chain
  const predictByMarkov = (data) => {
    if (data.length < 2) return null;
    const transitions = {};
    for (let i = 0; i < data.length - 1; i++) {
      const current = data[i];
      const next = data[i + 1];
      if (!transitions[current]) transitions[current] = {};
      transitions[current][next] = (transitions[current][next] || 0) + 1;
    }
    
    const lastValue = data[data.length - 1];
    if (transitions[lastValue]) {
      return parseInt(Object.keys(transitions[lastValue]).reduce((a, b) => 
        transitions[lastValue][a] > transitions[lastValue][b] ? a : b
      ));
    }
    return null;
  };

  // D·ª± ƒëo√°n theo regression ƒë∆°n gi·∫£n
  const predictByRegression = (data) => {
    if (data.length < 3) return null;
    const n = data.length;
    const sumX = (n * (n - 1)) / 2;
    const sumY = data.reduce((a, b) => a + b, 0);
    const sumXY = data.reduce((sum, y, x) => sum + x * y, 0);
    const sumX2 = (n * (n - 1) * (2 * n - 1)) / 6;
    
    const slope = (n * sumXY - sumX * sumY) / (n * sumX2 - sumX * sumX);
    const intercept = (sumY - slope * sumX) / n;
    
    return Math.round(Math.max(0, Math.min(4, slope * n + intercept)));
  };

  // T·ªïng h·ª£p c√°c d·ª± ƒëo√°n
  const combinePredictions = (predictions) => {
    const validPredictions = Object.values(predictions).filter(p => p !== null);
    if (validPredictions.length === 0) return { value: 2, confidence: 20 };
    
    const predictionCounts = {};
    validPredictions.forEach(p => {
      predictionCounts[p] = (predictionCounts[p] || 0) + 1;
    });
    
    const mostCommon = Object.keys(predictionCounts).reduce((a, b) => 
      predictionCounts[a] > predictionCounts[b] ? a : b
    );
    
    const confidence = Math.round((predictionCounts[mostCommon] / validPredictions.length) * 100);
    
    return {
      value: parseInt(mostCommon),
      confidence: confidence,
      methods: Object.keys(predictions).filter(k => predictions[k] == mostCommon),
      allPredictions: predictions
    };
  };

  // T·∫°o ph√¢n t√≠ch AI
  const generateAIAnalysis = (predictions, patterns, data) => {
    let analysis = [];
    
    if (patterns.trend > 0.3) {
      analysis.push("üìà Xu h∆∞·ªõng tƒÉng m·∫°nh ƒë∆∞·ª£c ph√°t hi·ªán");
    } else if (patterns.trend < -0.3) {
      analysis.push("üìâ Xu h∆∞·ªõng gi·∫£m m·∫°nh ƒë∆∞·ª£c ph√°t hi·ªán");
    } else {
      analysis.push("üìä D·ªØ li·ªáu t∆∞∆°ng ƒë·ªëi ·ªïn ƒë·ªãnh, kh√¥ng c√≥ xu h∆∞·ªõng r√µ r√†ng");
    }
    
    if (patterns.cycle) {
      analysis.push(`üîÑ Ph√°t hi·ªán pattern l·∫∑p l·∫°i: ${Object.keys(patterns.cycle)[0]}`);
    }
    
    const recentAvg = data.slice(-5).reduce((a, b) => a + b, 0) / Math.min(5, data.length);
    const overallAvg = parseFloat(patterns.average);
    
    if (recentAvg > overallAvg + 0.5) {
      analysis.push("‚¨ÜÔ∏è 5 l·∫ßn g·∫ßn ƒë√¢y c√≥ xu h∆∞·ªõng cao h∆°n trung b√¨nh");
    } else if (recentAvg < overallAvg - 0.5) {
      analysis.push("‚¨áÔ∏è 5 l·∫ßn g·∫ßn ƒë√¢y c√≥ xu h∆∞·ªõng th·∫•p h∆°n trung b√¨nh");
    }
    
    setAiAnalysis(analysis.join('\n'));
  };

  // X·ª≠ l√Ω nh·∫≠p l·ªãch s·ª≠
  const processHistoryInput = () => {
    try {
      const lines = historyInput.trim().split('\n');
      const newResults = [];
      
      lines.forEach((line, index) => {
        if (line.trim()) {
          // H·ªó tr·ª£ nhi·ªÅu format: "2" ho·∫∑c "ƒêTƒêT" ho·∫∑c "RTRT" v.v.
          let redCount;
          
          if (/^\d+$/.test(line.trim())) {
            // Format s·ªë: "2"
            redCount = parseInt(line.trim());
          } else {
            // Format chu·ªói: "ƒêTƒêT" ho·∫∑c "RTRT"
            const normalized = line.trim().toUpperCase();
            redCount = (normalized.match(/[ƒêDR1]/g) || []).length;
          }
          
          if (redCount >= 0 && redCount <= 4) {
            const outcome = Array(4).fill(0).map((_, i) => i < redCount ? 'ƒê·ªè' : 'Tr·∫Øng');
            newResults.push({
              flip: results.length + index + 1,
              outcome: outcome.join(', '),
              redCount: redCount,
              timestamp: new Date().toLocaleTimeString(),
              isImported: true
            });
          }
        }
      });
      
      if (newResults.length > 0) {
        setResults(prev => [...prev, ...newResults]);
        setFlipCount(prev => prev + newResults.length);
        setHistoryInput('');
        setShowHistoryInput(false);
        
        // Ph√¢n t√≠ch ngay sau khi nh·∫≠p
        setTimeout(() => analyzePatterns([...results, ...newResults]), 100);
      }
    } catch (error) {
      alert('L·ªói ƒë·ªãnh d·∫°ng d·ªØ li·ªáu. Vui l√≤ng ki·ªÉm tra l·∫°i!');
    }
  };

  // M√¥ ph·ªèng tung ƒë·ªìng ti·ªÅn
  const flipCoins = () => {
    if (isFlipping) return;
    
    setIsFlipping(true);
    setCoins(coins.map(coin => ({ ...coin, isFlipping: true, result: null })));
    
    setTimeout(() => {
      const newResults = coins.map(coin => ({
        ...coin,
        result: Math.random() < 0.5 ? 'ƒê·ªè' : 'Tr·∫Øng',
        isFlipping: false
      }));
      
      setCoins(newResults);
      setIsFlipping(false);
      setFlipCount(prev => prev + 1);
      
      // L∆∞u k·∫øt qu·∫£
      const outcome = newResults.map(coin => coin.result);
      const redCount = outcome.filter(result => result === 'ƒê·ªè').length;
      
      setResults(prev => {
        const newResults = [...prev, { 
          flip: prev.length + 1, 
          outcome: outcome.join(', '),
          redCount: redCount,
          timestamp: new Date().toLocaleTimeString(),
          isImported: false
        }];
        const finalResults = newResults.length > 50 ? newResults.slice(-50) : newResults;
        
        // Ph√¢n t√≠ch pattern sau khi c√≥ k·∫øt qu·∫£ m·ªõi
        setTimeout(() => analyzePatterns(finalResults), 100);
        
        return finalResults;
      });
    }, 1500);
  };

  // T√≠nh th·ªëng k√™ t·ª´ k·∫øt qu·∫£
  useEffect(() => {
    if (results.length === 0) {
      setStatistics({});
      return;
    }

    const redCounts = results.map(r => r.redCount);
    const stats = {};
    
    for (let i = 0; i <= 4; i++) {
      const count = redCounts.filter(rc => rc === i).length;
      stats[i] = {
        observed: count,
        observedPercent: (count / results.length * 100).toFixed(1),
        expected: (results.length * calculateProbabilities()[i].probability / 100).toFixed(1),
        expectedPercent: calculateProbabilities()[i].probability.toFixed(1)
      };
    }
    
    setStatistics(stats);
  }, [results]);

  // Ch·∫ø ƒë·ªô t·ª± ƒë·ªông
  useEffect(() => {
    if (autoMode && !isFlipping) {
      const timer = setTimeout(() => {
        flipCoins();
      }, 2000);
      return () => clearTimeout(timer);
    }
  }, [autoMode, isFlipping, coins]);

  const resetResults = () => {
    setResults([]);
    setFlipCount(0);
    setPrediction(null);
    setPatterns({});
    setAiAnalysis('');
    setCoins(coins.map(coin => ({ ...coin, result: null })));
  };

  const probabilities = calculateProbabilities();
  const pieData = Object.keys(statistics).map(key => ({
    name: `${key} ƒê·ªè`,
    value: parseFloat(statistics[key]?.observedPercent || 0),
    expected: parseFloat(statistics[key]?.expectedPercent || 0)
  }));

  const COLORS = ['#ef4444', '#f97316', '#eab308', '#22c55e', '#3b82f6'];

  return (
    <div className="min-h-screen bg-gradient-to-br from-red-50 to-blue-50 p-4">
      <div className="max-w-7xl mx-auto">
        {/* Header */}
        <div className="bg-white rounded-lg shadow-lg p-6 mb-6">
          <div className="flex items-center justify-between">
            <div className="flex items-center space-x-3">
              <Coins className="w-8 h-8 text-red-600" />
              <div>
                <h1 className="text-2xl font-bold text-gray-800">
                  D·ª± ƒëo√°n X√°c su·∫•t 4 ƒê·ªìng Ti·ªÅn
                </h1>
                <p className="text-gray-600">M√¥ ph·ªèng v√† ph√¢n t√≠ch x√°c su·∫•t m·∫∑t ƒê·ªè/Tr·∫Øng</p>
              </div>

        {/* Form nh·∫≠p l·ªãch s·ª≠ */}
        {showHistoryInput && (
          <div className="bg-white rounded-lg shadow-lg p-6 mb-6">
            <div className="flex items-center justify-between mb-4">
              <h2 className="text-lg font-semibold text-gray-800">Nh·∫≠p L·ªãch s·ª≠ K·∫øt qu·∫£</h2>
              <button
                onClick={() => setShowHistoryInput(false)}
                className="text-gray-500 hover:text-gray-700"
              >
                ‚úï
              </button>
            </div>
            
            <div className="grid grid-cols-1 lg:grid-cols-2 gap-6">
              <div>
                <label className="block text-sm font-medium text-gray-700 mb-2">
                  Nh·∫≠p k·∫øt qu·∫£ (m·ªói d√≤ng m·ªôt l·∫ßn tung):
                </label>
                <textarea
                  value={historyInput}
                  onChange={(e) => setHistoryInput(e.target.value)}
                  placeholder="V√≠ d·ª•:&#10;2&#10;1&#10;ƒêTƒêT&#10;3&#10;RTTR"
                  className="w-full h-32 px-3 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 font-mono text-sm"
                />
                <div className="flex justify-between mt-2">
                  <button
                    onClick={processHistoryInput}
                    className="px-4 py-2 bg-blue-500 hover:bg-blue-600 text-white rounded-lg"
                  >
                    X·ª≠ l√Ω d·ªØ li·ªáu
                  </button>
                  <span className="text-sm text-gray-500">
                    {historyInput.split('\n').filter(line => line.trim()).length} d√≤ng
                  </span>
                </div>
              </div>
              
              <div>
                <h3 className="text-sm font-medium text-gray-700 mb-2">H∆∞·ªõng d·∫´n ƒë·ªãnh d·∫°ng:</h3>
                <div className="space-y-2 text-sm text-gray-600">
                  <div className="p-2 bg-gray-50 rounded">
                    <strong>ƒê·ªãnh d·∫°ng s·ªë:</strong> Nh·∫≠p s·ªë ƒë·ªìng ƒë·ªè (0-4)
                    <br />V√≠ d·ª•: 2 (c√≥ 2 ƒë·ªìng ƒë·ªè, 2 ƒë·ªìng tr·∫Øng)
                  </div>
                  <div className="p-2 bg-gray-50 rounded">
                    <strong>ƒê·ªãnh d·∫°ng k√Ω t·ª±:</strong> ƒê/D/R/1 = ƒê·ªè, T/W/0 = Tr·∫Øng
                    <br />V√≠ d·ª•: ƒêTƒêT ho·∫∑c RTTR
                  </div>
                  <div className="p-2 bg-yellow-50 rounded border border-yellow-200">
                    <strong>L∆∞u √Ω:</strong> M·ªói d√≤ng l√† m·ªôt l·∫ßn tung, t·ªëi ƒëa 4 ƒë·ªìng ti·ªÅn
                  </div>
                </div>
              </div>
            </div>
          </div>
        )}
            </div>
            <div className="flex items-center space-x-4">
              <div className="text-sm text-gray-600">
                S·ªë l·∫ßn tung: <span className="font-bold text-blue-600">{flipCount}</span>
              </div>
              <button
                onClick={() => setShowHistoryInput(!showHistoryInput)}
                className="flex items-center space-x-2 px-4 py-2 bg-purple-500 hover:bg-purple-600 text-white rounded-lg"
              >
                <Upload className="w-4 h-4" />
                <span>Nh·∫≠p l·ªãch s·ª≠</span>
              </button>
              <button
                onClick={resetResults}
                className="flex items-center space-x-2 px-4 py-2 bg-gray-500 hover:bg-gray-600 text-white rounded-lg"
              >
                <RotateCcw className="w-4 h-4" />
                <span>Reset</span>
              </button>
              <button
                onClick={() => setAutoMode(!autoMode)}
                className={`flex items-center space-x-2 px-4 py-2 rounded-lg font-medium ${
                  autoMode 
                    ? 'bg-orange-500 hover:bg-orange-600 text-white' 
                    : 'bg-green-500 hover:bg-green-600 text-white'
                }`}
              >
                {autoMode ? <Pause className="w-4 h-4" /> : <Play className="w-4 h-4" />}
                <span>{autoMode ? 'D·ª´ng t·ª± ƒë·ªông' : 'T·ª± ƒë·ªông'}</span>
              </button>
              <button
                onClick={flipCoins}
                disabled={isFlipping}
                className="flex items-center space-x-2 px-6 py-2 bg-blue-500 hover:bg-blue-600 disabled:bg-gray-400 text-white rounded-lg font-medium"
              >
                <Coins className="w-4 h-4" />
                <span>{isFlipping ? 'ƒêang tung...' : 'Tung ƒë·ªìng ti·ªÅn'}</span>
              </button>
            </div>
          </div>
        </div>

        <div className="grid grid-cols-1 xl:grid-cols-3 gap-6 mb-6">
          {/* D·ª± ƒëo√°n AI */}
          {prediction && (
            <div className="bg-gradient-to-br from-purple-50 to-blue-50 rounded-lg shadow-lg p-6 border-2 border-purple-200">
              <div className="flex items-center justify-between mb-4">
                <h2 className="text-lg font-semibold text-purple-800">üîÆ D·ª± ƒëo√°n l·∫ßn ti·∫øp theo</h2>
                <Brain className="w-6 h-6 text-purple-600" />
              </div>
              
              <div className="text-center mb-4">
                <div className="text-4xl font-bold text-purple-600 mb-2">
                  {prediction.value} ƒê·ªè
                </div>
                <div className="flex items-center justify-center space-x-2">
                  <Target className="w-4 h-4 text-green-600" />
                  <span className="text-sm font-medium text-green-600">
                    ƒê·ªô tin c·∫≠y: {prediction.confidence}%
                  </span>
                </div>
              </div>

              <div className="space-y-2">
                <div className="text-xs text-purple-700">
                  <strong>Ph∆∞∆°ng ph√°p ƒë·ªìng thu·∫≠n:</strong>
                </div>
                {prediction.methods && prediction.methods.map((method, index) => (
                  <div key={index} className="text-xs bg-purple-100 px-2 py-1 rounded">
                    {method === 'trend' && 'üìà Ph√¢n t√≠ch xu h∆∞·ªõng'}
                    {method === 'cycle' && 'üîÑ Ph√°t hi·ªán chu k·ª≥'}
                    {method === 'frequency' && 'üìä T·∫ßn su·∫•t xu·∫•t hi·ªán'}
                    {method === 'markov' && 'üîó Chu·ªói Markov'}
                    {method === 'regression' && 'üìâ H·ªìi quy tuy·∫øn t√≠nh'}
                  </div>
                ))}
              </div>

              {aiAnalysis && (
                <div className="mt-4 p-3 bg-white rounded border border-purple-200">
                  <div className="text-xs font-medium text-purple-700 mb-1">Ph√¢n t√≠ch AI:</div>
                  <div className="text-xs text-gray-700 whitespace-pre-line">
                    {aiAnalysis}
                  </div>
                </div>
              )}
            </div>
          )}

          {/* Patterns ph√°t hi·ªán */}
          {Object.keys(patterns).length > 0 && (
            <div className="bg-white rounded-lg shadow-lg p-6">
              <div className="flex items-center justify-between mb-4">
                <h2 className="text-lg font-semibold text-gray-800">üìä Patterns ph√°t hi·ªán</h2>
              </div>
              
              <div className="space-y-3">
                <div className="p-2 bg-gray-50 rounded">
                  <div className="text-sm font-medium text-gray-700">Xu h∆∞·ªõng:</div>
                  <div className="text-xs text-gray-600">
                    {patterns.trend > 0.3 ? 'üìà TƒÉng' : patterns.trend < -0.3 ? 'üìâ Gi·∫£m' : '‚û°Ô∏è ·ªîn ƒë·ªãnh'} 
                    ({patterns.trend?.toFixed(2)})
                  </div>
                </div>
                
                <div className="p-2 bg-gray-50 rounded">
                  <div className="text-sm font-medium text-gray-700">Trung b√¨nh:</div>
                  <div className="text-xs text-gray-600">{patterns.average} ƒë·ªè/l·∫ßn</div>
                </div>
                
                {patterns.recent && (
                  <div className="p-2 bg-gray-50 rounded">
                    <div className="text-sm font-medium text-gray-700">5 l·∫ßn g·∫ßn nh·∫•t:</div>
                    <div className="text-xs text-gray-600">{patterns.recent.join(', ')}</div>
                  </div>
                )}
                
                {patterns.cycle && (
                  <div className="p-2 bg-yellow-50 rounded border border-yellow-200">
                    <div className="text-sm font-medium text-yellow-800">Chu k·ª≥ l·∫∑p:</div>
                    <div className="text-xs text-yellow-700">
                      {Object.keys(patterns.cycle)[0]} (l·∫∑p {Object.values(patterns.cycle)[0]} l·∫ßn)
                    </div>
                  </div>
                )}
              </div>
            </div>
          )}

          {/* Bi·ªÉu ƒë·ªì xu h∆∞·ªõng */}
          {results.length > 2 && (
            <div className="bg-white rounded-lg shadow-lg p-6">
              <h2 className="text-lg font-semibold text-gray-800 mb-4">üìà Xu h∆∞·ªõng theo th·ªùi gian</h2>
              <ResponsiveContainer width="100%" height={200}>
                <LineChart data={results.slice(-15).map((result, index) => ({
                  flip: result.flip,
                  redCount: result.redCount,
                  average: results.slice(0, results.indexOf(result) + 1)
                    .reduce((sum, r) => sum + r.redCount, 0) / (results.indexOf(result) + 1)
                }))}>
                  <CartesianGrid strokeDasharray="3 3" />
                  <XAxis dataKey="flip" />
                  <YAxis domain={[0, 4]} />
                  <Tooltip />
                  <Line type="monotone" dataKey="redCount" stroke="#ef4444" strokeWidth={2} name="S·ªë ƒë·ªè" />
                  <Line type="monotone" dataKey="average" stroke="#3b82f6" strokeWidth={2} strokeDasharray="5 5" name="TB t√≠ch l≈©y" />
                </LineChart>
              </ResponsiveContainer>
            </div>
          )}
          {/* Hi·ªÉn th·ªã 4 ƒë·ªìng ti·ªÅn */}
          {coins.map((coin, index) => (
            <div key={coin.id} className="bg-white rounded-lg shadow-lg p-6">
              <div className="text-center">
                <h3 className="text-lg font-semibold text-gray-800 mb-4">
                  ƒê·ªìng ti·ªÅn {coin.id}
                </h3>
                <div className="relative w-24 h-24 mx-auto mb-4">
                  <div className={`w-24 h-24 rounded-full flex items-center justify-center text-white font-bold text-lg transition-all duration-300 ${
                    coin.isFlipping ? 'animate-spin' : ''
                  } ${
                    coin.result === 'ƒê·ªè' ? 'bg-red-500' :
                    coin.result === 'Tr·∫Øng' ? 'bg-gray-300 text-gray-700' :
                    'bg-gray-200 border-4 border-dashed border-gray-400'
                  }`}>
                    {coin.isFlipping ? '?' : (coin.result || '?')}
                  </div>
                </div>
                <div className="text-sm text-gray-600">
                  {coin.result ? coin.result : 'Ch·ªù k·∫øt qu·∫£'}
                </div>
              </div>
            </div>
          ))}
        </div>

        <div className="grid grid-cols-1 xl:grid-cols-2 gap-6 mb-6">
          {/* B·∫£ng x√°c su·∫•t l√Ω thuy·∫øt */}
          <div className="bg-white rounded-lg shadow-lg p-6">
            <div className="flex items-center justify-between mb-4">
              <h2 className="text-lg font-semibold text-gray-800">X√°c su·∫•t L√Ω thuy·∫øt</h2>
              <Calculator className="w-5 h-5 text-blue-600" />
            </div>
            
            <div className="space-y-3">
              {probabilities.map((prob, index) => (
                <div key={index} className="flex items-center justify-between p-3 bg-gray-50 rounded-lg">
                  <div className="flex items-center space-x-3">
                    <div className="w-3 h-3 rounded-full" style={{ backgroundColor: COLORS[index] }}></div>
                    <span className="font-medium text-gray-700">{prob.outcome}</span>
                  </div>
                  <div className="text-right">
                    <div className="font-bold text-blue-600">{prob.probability.toFixed(1)}%</div>
                    <div className="text-xs text-gray-500">{prob.count}/16 tr∆∞·ªùng h·ª£p</div>
                  </div>
                </div>
              ))}
            </div>
            
            <div className="mt-4 p-3 bg-blue-50 rounded-lg">
              <p className="text-sm text-blue-700">
                <strong>C√¥ng th·ª©c:</strong> C(4,k) √ó (1/2)‚Å¥ = C(4,k)/16
              </p>
              <p className="text-xs text-blue-600 mt-1">
                V·ªõi C(4,k) l√† s·ªë c√°ch ch·ªçn k ƒë·ªìng ƒë·ªè t·ª´ 4 ƒë·ªìng
              </p>
            </div>
          </div>

          {/* So s√°nh k·∫øt qu·∫£ th·ª±c t·∫ø vs l√Ω thuy·∫øt */}
          <div className="bg-white rounded-lg shadow-lg p-6">
            <div className="flex items-center justify-between mb-4">
              <h2 className="text-lg font-semibold text-gray-800">So s√°nh Th·ª±c t·∫ø vs L√Ω thuy·∫øt</h2>
              <TrendingUp className="w-5 h-5 text-green-600" />
            </div>
            
            {results.length > 0 ? (
              <div className="space-y-3">
                {Object.keys(statistics).map((key) => (
                  <div key={key} className="p-3 bg-gray-50 rounded-lg">
                    <div className="flex justify-between items-center mb-2">
                      <span className="font-medium text-gray-700">{key} ƒê·ªè</span>
                      <div className="flex space-x-4 text-sm">
                        <span className="text-green-600">
                          Th·ª±c: {statistics[key].observedPercent}%
                        </span>
                        <span className="text-blue-600">
                          L√Ω: {statistics[key].expectedPercent}%
                        </span>
                      </div>
                    </div>
                    <div className="flex space-x-2">
                      <div className="flex-1 bg-gray-200 rounded-full h-2">
                        <div 
                          className="bg-green-500 h-2 rounded-full"
                          style={{ width: `${Math.min(100, statistics[key].observedPercent * 2)}%` }}
                        />
                      </div>
                      <div className="flex-1 bg-gray-200 rounded-full h-2">
                        <div 
                          className="bg-blue-500 h-2 rounded-full"
                          style={{ width: `${Math.min(100, statistics[key].expectedPercent * 2)}%` }}
                        />
                      </div>
                    </div>
                  </div>
                ))}
              </div>
            ) : (
              <div className="text-center text-gray-500 py-8">
                <Coins className="w-12 h-12 mx-auto mb-2 opacity-50" />
                <p>Ch∆∞a c√≥ d·ªØ li·ªáu</p>
                <p className="text-sm">Tung ƒë·ªìng ti·ªÅn ƒë·ªÉ xem so s√°nh</p>
              </div>
            )}
          </div>
        </div>

        {/* Bi·ªÉu ƒë·ªì v√† l·ªãch s·ª≠ */}
        <div className="grid grid-cols-1 xl:grid-cols-2 gap-6">
          {/* Bi·ªÉu ƒë·ªì c·ªôt */}
          <div className="bg-white rounded-lg shadow-lg p-6">
            <h2 className="text-lg font-semibold text-gray-800 mb-4">Ph√¢n b·ªë K·∫øt qu·∫£</h2>
            
            {results.length > 0 ? (
              <ResponsiveContainer width="100%" height={300}>
                <BarChart data={probabilities.map((prob, index) => ({
                  name: `${index} ƒê·ªè`,
                  expected: prob.probability,
                  observed: parseFloat(statistics[index]?.observedPercent || 0)
                }))}>
                  <CartesianGrid strokeDasharray="3 3" />
                  <XAxis dataKey="name" />
                  <YAxis />
                  <Tooltip formatter={(value, name) => [`${value.toFixed(1)}%`, name === 'expected' ? 'L√Ω thuy·∫øt' : 'Th·ª±c t·∫ø']} />
                  <Bar dataKey="expected" fill="#3b82f6" name="L√Ω thuy·∫øt" />
                  <Bar dataKey="observed" fill="#10b981" name="Th·ª±c t·∫ø" />
                </BarChart>
              </ResponsiveContainer>
            ) : (
              <div className="text-center text-gray-500 py-16">
                <p>Ch∆∞a c√≥ d·ªØ li·ªáu ƒë·ªÉ hi·ªÉn th·ªã bi·ªÉu ƒë·ªì</p>
              </div>
            )}
          </div>

          {/* L·ªãch s·ª≠ k·∫øt qu·∫£ */}
          <div className="bg-white rounded-lg shadow-lg p-6">
            <h2 className="text-lg font-semibold text-gray-800 mb-4">
              L·ªãch s·ª≠ K·∫øt qu·∫£ (10 l·∫ßn g·∫ßn nh·∫•t)
            </h2>
            
            <div className="max-h-72 overflow-y-auto">
              {results.length > 0 ? (
                <div className="space-y-2">
                  {results.slice(-10).reverse().map((result, index) => (
                    <div key={result.flip} className="flex items-center justify-between p-2 bg-gray-50 rounded">
                      <div className="flex items-center space-x-3">
                        <span className="text-sm font-medium text-gray-600">#{result.flip}</span>
                        <div className="flex space-x-1">
                          {result.outcome.split(', ').map((coin, coinIndex) => (
                            <div
                              key={coinIndex}
                              className={`w-6 h-6 rounded-full flex items-center justify-center text-xs font-bold ${
                                coin === 'ƒê·ªè' ? 'bg-red-500 text-white' : 'bg-gray-300 text-gray-700'
                              }`}
                            >
                              {coin === 'ƒê·ªè' ? 'ƒê' : 'T'}
                            </div>
                          ))}
                        </div>
                      </div>
                      <div className="text-right">
                        <div className="text-sm font-medium text-blue-600">
                          {result.redCount} ƒê·ªè
                        </div>
                        <div className="text-xs text-gray-500 flex items-center">
                          {result.isImported && <span className="text-purple-500 mr-1">üì•</span>}
                          {result.timestamp}
                        </div>
                      </div>
                    </div>
                  ))}
                </div>
              ) : (
                <div className="text-center text-gray-500 py-8">
                  <p>Ch∆∞a c√≥ l·ªãch s·ª≠</p>
                  <p className="text-sm">Tung ƒë·ªìng ti·ªÅn ƒë·ªÉ xem k·∫øt qu·∫£</p>
                </div>
              )}
            </div>
          </div>
        </div>

        {/* C√¥ng th·ª©c v√† gi·∫£i th√≠ch */}
        <div className="bg-white rounded-lg shadow-lg p-6 mt-6">
          <h2 className="text-lg font-semibold text-gray-800 mb-4">C√¥ng th·ª©c T√≠nh X√°c su·∫•t</h2>
          
          <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
            <div>
              <h3 className="font-medium text-gray-700 mb-2">X√°c su·∫•t c√≥ k ƒë·ªìng ƒë·ªè:</h3>
              <div className="bg-gray-50 p-4 rounded-lg font-mono text-sm">
                P(k ƒë·ªè) = C(4,k) √ó (1/2)‚Å¥<br/>
                = C(4,k) / 16
              </div>
              <p className="text-sm text-gray-600 mt-2">
                V·ªõi C(4,k) = 4!/(k!(4-k)!) l√† t·ªï h·ª£p ch·ªçn k t·ª´ 4
              </p>
            </div>
            
            <div>
              <h3 className="font-medium text-gray-700 mb-2">V√≠ d·ª• t√≠nh C(4,k):</h3>
              <div className="bg-gray-50 p-4 rounded-lg font-mono text-sm space-y-1">
                C(4,0) = 1 &nbsp;&nbsp; C(4,1) = 4<br/>
                C(4,2) = 6 &nbsp;&nbsp; C(4,3) = 4<br/>
                C(4,4) = 1
              </div>
              <p className="text-sm text-gray-600 mt-2">
                T·ªïng: 1+4+6+4+1 = 16 tr∆∞·ªùng h·ª£p
              </p>
            </div>
          </div>
        </div>
      </div>
    </div>
  );
};

export default CoinProbabilityPredictor;
